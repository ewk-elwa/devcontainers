# Kubernetes Questions

## What is Kubernetes, and what problems does it solve?
### Answer:
  -	Kubernetes is an open-source container orchestration platform designed to automate the deployment, scaling, and management of containerized applications. It solves problems like:
  -	Manual container orchestration.
  -	Scaling containers dynamically based on load.
  -	High availability and self-healing.
  -	Managing container networking and service discovery.

## Explain the architecture of Kubernetes.
### Answer: 
  - Kubernetes has a master-worker architecture:
		Master Components:
	-	API Server: Front-end for Kubernetes, handling RESTful requests.
	-	Controller Manager: Ensures the desired state by reconciling resources.
	-	Scheduler: Assigns workloads to nodes based on resource availability.
	-	etcd: A key-value store for cluster state data.
	-	Worker Node Components:
	-	Kubelet: Agent on each node that communicates with the master.
	-	Kube-proxy: Handles networking and load balancing.
	-	Container Runtime: E.g., Docker or containerd, for running containers.

## What is a Pod in Kubernetes?
### Answer: 
  - A Pod is the smallest deployable unit in Kubernetes. It represents a single instance of a running process in the cluster and can contain one or more tightly coupled containers sharing the same network namespace and storage.

## How does Kubernetes handle scaling?
### Answer: 
  - Kubernetes supports two types of scaling:
	- Horizontal Pod Autoscaler (HPA): Scales the number of Pods based on CPU/memory utilization or custom metrics.
  - Cluster Autoscaler: Scales the number of nodes in a cluster based on pending Pods.

5. What is the difference between a Deployment, StatefulSet, and DaemonSet?
### Answer:
  -	Deployment: Manages stateless applications, ensuring the desired number of Pods are running.
  -	StatefulSet: Manages stateful applications, providing unique identifiers and stable storage for each Pod.
  -	DaemonSet: Ensures that a Pod runs on every (or specified) node in the cluster, typically for logging or monitoring.

6. How does service discovery work in Kubernetes?
### Answer: Kubernetes uses Services to expose Pods to other Pods or external clients. There are three types:
  -	ClusterIP: Default, exposes the service within the cluster.
  -	NodePort: Exposes the service on a static port on each node.
  -	LoadBalancer: Exposes the service externally using a cloud provider’s load balancer.

7. What are ConfigMaps and Secrets in Kubernetes?
### Answer:
  -	ConfigMaps: Store configuration data as key-value pairs, which can be injected into Pods.
  -	Secrets: Similar to ConfigMaps but designed to store sensitive data, such as API keys and passwords, in a more secure way (base64-encoded).

Containerization Questions

8. What is the difference between a VM and a container?
### Answer:
  -	VM: Emulates hardware, runs a full OS for each instance, and is resource-heavy.
  -	Container: Shares the host OS kernel, isolates processes, and is lightweight and faster to start.

9. How does Docker build, store, and run containers?
### Answer:
  -	Build: Docker uses a Dockerfile to create images through a series of layered instructions.
  -	Store: Images are stored in Docker registries like Docker Hub.
  -	Run: Docker containers are instances of Docker images that execute in isolated environments.

10. What are Docker Volumes, and why are they used?
### Answer: Docker Volumes are used to persist data generated by a container. Unlike container-layer storage, volumes are managed outside the container’s lifecycle and can be shared between containers.

11. How is networking handled in Docker?
### Answer: Docker uses five main networking modes:
  -	Bridge: Default, isolates containers in a private network.
  -	Host: Shares the host’s network namespace.
  -	None: Disables networking.
  -	Overlay: Connects multiple Docker daemons across a swarm.
  -	Macvlan: Assigns MAC addresses to containers for direct host access.

# Microservices Questions

## What are microservices, and how do they differ from monolithic architecture?
### Answer:
  -	Microservices: An architectural style where an application is composed of small, independently deployable services, each responsible for a specific business function.
  -	Differences:
  -	Microservices are loosely coupled, while monolithic apps are tightly integrated.
  -	Microservices can scale independently, whereas monoliths scale as a whole.

## How do microservices communicate with each other?
### Answer:
  -	Synchronous: HTTP/REST, gRPC.
  -	Asynchronous: Message brokers like RabbitMQ, Kafka, or AWS SQS.

## What are common challenges in microservices architecture?
### Answer:
  -	Service discovery: Locating services dynamically.
  -	Data consistency: Managing distributed transactions.
  -	Monitoring and debugging: Tracing requests across multiple services.
  -	Network latency: Increased inter-service communication.

## How do you ensure resilience in a microservices system?
## Answer:
  -	Implement circuit breakers (e.g., Netflix Hystrix).
  -	Use retries with exponential backoff.
  -	Apply load balancing.
  -	Design for failure using patterns like bulkheads.

## What is the role of API Gateways in microservices?
### Answer: 
  - An API Gateway acts as a single entry point for clients, handling:
  - Routing requests to appropriate services.
  - Authentication and authorization.
  - Load balancing and rate limiting.
  - Response aggregation.

## How do you handle data consistency across microservices?
### Answer: 
  - Use techniques like:
  - Event Sourcing: Storing changes as a sequence of events.
  - Saga Pattern: Managing distributed transactions via a series of compensating actions.

## What tools would you use for monitoring microservices?
### Answer:
	- Logging: ELK Stack (Elasticsearch, Logstash, Kibana).
	- Metrics: Prometheus, Grafana.
	- Distributed Tracing: Jaeger, Zipkin.
	- Service Mesh: Istio for observability, traffic control, and security.

Let me know if you’d like follow-up questions or deeper dives into specific areas!
